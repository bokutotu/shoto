diff --git a/isl/src/ISL/FFI.hs b/isl/src/ISL/FFI.hs
index afe45c4..63dfc4a 100644
--- a/isl/src/ISL/FFI.hs
+++ b/isl/src/ISL/FFI.hs
@@ -44,6 +44,18 @@ module ISL.FFI (
     c_sched_free,
     c_sched_from_domain,
     c_sched_get_domain,
+
+    -- * Schedule Node Types
+    IslScheduleNode,
+    RawScheduleNode,
+
+    -- * Schedule Node FFI
+    c_sched_get_root,
+    c_sched_node_free,
+    c_sched_node_copy,
+    c_sched_node_get_type,
+    c_sched_node_n_children,
+    c_sched_node_get_child,
 ) where
 
 import           Foreign.C.String (CString)
@@ -59,6 +71,8 @@ data IslUnionSet
 
 data IslSchedule
 
+data IslScheduleNode
+
 type RawCtx = Ptr IslCtx
 
 type RawSet = Ptr IslSet
@@ -67,6 +81,8 @@ type RawUnionSet = Ptr IslUnionSet
 
 type RawSchedule = Ptr IslSchedule
 
+type RawScheduleNode = Ptr IslScheduleNode
+
 -- Context
 foreign import ccall "isl/ctx.h isl_ctx_alloc"
     c_ctx_alloc :: IO RawCtx
@@ -148,3 +164,22 @@ foreign import ccall "isl/schedule.h isl_schedule_from_domain"
 
 foreign import ccall "isl/schedule.h isl_schedule_get_domain"
     c_sched_get_domain :: RawSchedule -> IO RawUnionSet
+
+-- Schedule Node
+foreign import ccall "isl/schedule.h isl_schedule_get_root"
+    c_sched_get_root :: RawSchedule -> IO RawScheduleNode
+
+foreign import ccall "isl/schedule_node.h isl_schedule_node_free"
+    c_sched_node_free :: RawScheduleNode -> IO ()
+
+foreign import ccall "isl/schedule_node.h isl_schedule_node_copy"
+    c_sched_node_copy :: RawScheduleNode -> IO RawScheduleNode
+
+foreign import ccall "isl/schedule_node.h isl_schedule_node_get_type"
+    c_sched_node_get_type :: RawScheduleNode -> IO CInt
+
+foreign import ccall "isl/schedule_node.h isl_schedule_node_n_children"
+    c_sched_node_n_children :: RawScheduleNode -> IO CInt
+
+foreign import ccall "isl/schedule_node.h isl_schedule_node_get_child"
+    c_sched_node_get_child :: RawScheduleNode -> CInt -> IO RawScheduleNode
diff --git a/isl/src/ISL/Schedule.hs b/isl/src/ISL/Schedule.hs
index ddddeb9..dbbaf82 100644
--- a/isl/src/ISL/Schedule.hs
+++ b/isl/src/ISL/Schedule.hs
@@ -4,18 +4,25 @@
 module ISL.Schedule (
     -- * Types
     Schedule (..),
+    ScheduleNode (..),
+    ScheduleTree (..),
 
     -- * Schedule Operations
     schedule,
     scheduleToString,
     scheduleDomain,
     scheduleFromDomain,
+
+    -- * Schedule Tree Traversal
+    scheduleRoot,
+    scheduleTree,
 ) where
 
 import           Control.Exception      (bracket)
 import           Control.Monad.IO.Class (liftIO)
 import           Data.String            (IsString (..))
 import           Foreign.C.String       (peekCString, withCString)
+import           Foreign.C.Types        (CInt (..))
 import           Foreign.ForeignPtr     (ForeignPtr, withForeignPtr)
 import           Foreign.Marshal.Alloc  (free)
 import           Foreign.Ptr            (nullPtr)
@@ -55,3 +62,89 @@ scheduleFromDomain (UnionSet fp) = do
             cptr <- c_uset_copy ptr
             c_sched_from_domain cptr
     manage c_sched_free "isl_schedule_from_domain" mk Schedule
+
+-- | Schedule node wrapper
+newtype ScheduleNode s = ScheduleNode (ForeignPtr IslScheduleNode)
+
+-- | Haskell representation of ISL schedule tree
+data ScheduleTree
+    = -- | Loop structure
+      TreeBand [ScheduleTree]
+    | -- | Sequential execution block
+      TreeSequence [ScheduleTree]
+    | -- | Unordered set
+      TreeSet [ScheduleTree]
+    | -- | Filter/condition
+      TreeFilter [ScheduleTree]
+    | -- | Domain node (root)
+      TreeDomain [ScheduleTree]
+    | -- | Marker/annotation
+      TreeMark [ScheduleTree]
+    | -- | Extension node
+      TreeExtension [ScheduleTree]
+    | -- | Expansion node
+      TreeExpansion [ScheduleTree]
+    | -- | Guard node
+      TreeGuard [ScheduleTree]
+    | -- | Leaf node (terminal)
+      TreeLeaf
+    deriving (Show, Eq)
+
+-- Node type constants from isl/schedule_type.h
+-- Note: error(0) and context(2) are omitted as they're not used in tensor computation
+nodeTypeBand, nodeTypeDomain, nodeTypeExpansion, nodeTypeExtension :: CInt
+nodeTypeFilter, nodeTypeGuard, nodeTypeLeaf, nodeTypeMark :: CInt
+nodeTypeSequence, nodeTypeSet :: CInt
+nodeTypeBand = 1
+nodeTypeDomain = 3
+nodeTypeExpansion = 4
+nodeTypeExtension = 5
+nodeTypeFilter = 6
+nodeTypeGuard = 7
+nodeTypeLeaf = 8
+nodeTypeMark = 9
+nodeTypeSequence = 10
+nodeTypeSet = 11
+
+-- | Get the root node of a schedule
+scheduleRoot :: Schedule s -> ISL s (ScheduleNode s)
+scheduleRoot (Schedule schedFP) = do
+    let mk = withForeignPtr schedFP c_sched_get_root
+    manage c_sched_node_free "isl_schedule_get_root" mk ScheduleNode
+
+-- | Convert a schedule to a ScheduleTree
+scheduleTree :: Schedule s -> ISL s ScheduleTree
+scheduleTree sched = do
+    root <- scheduleRoot sched
+    walkNode root
+
+-- | Recursively traverse a schedule node
+walkNode :: ScheduleNode s -> ISL s ScheduleTree
+walkNode (ScheduleNode nodeFP) = do
+    t <- liftIO $ withForeignPtr nodeFP c_sched_node_get_type
+    n <- liftIO $ withForeignPtr nodeFP c_sched_node_n_children
+
+    children <- mapM (\i -> getChild nodeFP (fromIntegral i) >>= walkNode) [0 .. n - 1]
+
+    pure $ case t of
+        _ | t == nodeTypeBand      -> TreeBand children
+        _ | t == nodeTypeSequence  -> TreeSequence children
+        _ | t == nodeTypeSet       -> TreeSet children
+        _ | t == nodeTypeFilter    -> TreeFilter children
+        _ | t == nodeTypeDomain    -> TreeDomain children
+        _ | t == nodeTypeMark      -> TreeMark children
+        _ | t == nodeTypeExtension -> TreeExtension children
+        _ | t == nodeTypeExpansion -> TreeExpansion children
+        _ | t == nodeTypeGuard     -> TreeGuard children
+        _ | t == nodeTypeLeaf      -> TreeLeaf
+        _                          -> TreeLeaf -- Unknown type, treat as leaf
+  where
+    -- Safely get a child node
+    -- IMPORTANT: c_sched_node_get_child consumes (__isl_take) the parent pointer,
+    -- so we MUST copy it first to avoid double-free when ForeignPtr finalizer runs
+    getChild :: ForeignPtr IslScheduleNode -> Int -> ISL s (ScheduleNode s)
+    getChild parentFP idx = do
+        let mk = withForeignPtr parentFP $ \parentPtr -> do
+                parentCopy <- c_sched_node_copy parentPtr
+                c_sched_node_get_child parentCopy (fromIntegral idx)
+        manage c_sched_node_free "isl_schedule_node_get_child" mk ScheduleNode
